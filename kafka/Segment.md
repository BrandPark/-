# Segment
> 카프카의 토픽으로 들어오는 메시지(레코드)는 브로커의 로컬 디스크에 세크먼트라는 파일에 저장됩니다.

- `메시지의 내용`뿐만 아니라 `메시지의 키`, `값`, `오프셋`, `메시지 크기` 같은 정보가 함께 저장됩니다.
- 관리를 위해 세그먼트 파일의 최대 크기는 정해져있습니다. **기본값은 1GB**입니다.
  - 1GB를 초과할 경우 기본적으로 `롤링 전략`을 적용합니다.
  - 인입되는 메시지를 하나의 세그먼트에 덧붙이다가 일정 치에 도달하면 파일을 close하고 새로운 세그먼트를 생성합니다.

이렇게 롤링 전략이 준비되어 있긴 하지만, **세그먼트 파일이 무한히 늘어날 경우를 대비해 로그 세그먼트에 대한 관리 계획을 수립해 둘 필요**가 있습니다.
크게 세그먼트 삭제와 컴팩션으로 구분할 수 있습니다.

## 로그 세그먼트 삭제
> 일정 주기로 세그먼트 파일을 체크하여 삭제 작업을 수행합니다. 

- `retention.ms`옵션으로 유지기간을 설정하거나, `retention.byte`옵션으로 크기를 설정하여 기준을 넘어서면 삭제할 수 있습니다.
  - `retention.ms`의 기본 값은 7일입니다.
- `server.properties`에 `log.cleanup.policy = delete`로 설정해야 합니다. 기본값입니다.
- 일정 주기로 체크를 하게 되는데, **기본값은 5분** 주기입니다.

## 로그 세그먼트 컴팩션
> 로그를 삭제하지 않고 컴팩션하여 보관합니다. 현재 활성화된 세그먼트를 제외하고 나머지 세그먼트들을 대상으로 실행됩니다.

- 메시지(레코드)의 키값을 기준으로 마지막의 데이터만 보관하게 됩니다.
  - 메시지의 키값을 기준으로 가장 마지막 값이 필요한 경우에 사용.
  - 같은 키값으로 메시지들이 들어오면 모두 저장되어 있다가 컴팩션을 통해 가장 마지막 메시지를 제외하고 모두 삭제 됩니다.
- 대표적인 예제로 `__consumer_offset` 토픽이 있습니다.
  - 토픽에 대한 컨슈머 그룹의 마지막 오프셋만을 저장합니다.
- 컴팩션 기능을 사용하려면 **카프카로 메시지를 전송할 때 키도 필수값으로 전송**해야합니다.

### 로그 세그먼트 컴팩션 사용시 주의 사항

로그 컴팩션은 복구 시 전체 로그를 복구하지 않고, 메시지의 키를 기준으로 최신의 상태만 복구합니다. 
따라서 전체 로그를 복구할 때보다 **빠르게 장애를 복구**할 수 있습니다.

하지만 빠르게 장애를 복구(재처리) 할수 있다고 해서 모든 토픽에 적용하는 것은 좋지 않습니다.
다음을 주의 하면서 적용하는게 좋습니다.
- 키값을 기준으로 최종값만 필요한 워크로드인가?
- 로그 컴팩션 작업이 실행되는 동안 **브로커의 과도한 입출력 부하가 발생할 수 있습니다.**
  - 따라서 **반드시 브로커의 리소스 모니터링도 병행**하여 로그 컴팩션을 사용하는게 좋습니다.

### 관련 옵션
- `cleanup.policy = compact`
  - 토픽 레벨에서 로그 컴팩션을 설정할 때 적용하는 옵션입니다.
- `log.cleanup.policy = compact`
  - 브로커 레벨에서 로그 컴팩션을 설정할 때 적용하는 옵션입니다.
- `log.cleaner.min.compaction.lag.ms = 0`
  - 메시지가 기록된 후 컴팩션하기 전 경과되어야 할 최소 시간입니다.
- `lg.cleaner.max.compaction.lag.ms = 9223372936854775807`
  - 컴팩션하기 전 경과되어야 할 최대 시간입니다.
- `log.cleaner.min.cleanable.ratio = 0.5`
  - 로그에서 압축이 되지 않은 부분을 더티라고 표현합니다.
  - 전체 로그 대비 더티의 비율이 50%가 넘으면 로그 컴팩션이 실행됩니다.
