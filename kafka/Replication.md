# Replication
> 토픽의 파티션을 클러스터 내의 브로커들에 분산시켜 저장하는 것을 의미합니다.

카프카는 고가용성과 안전성을 확보하기 위해 클러스터 내 브로커들에 토픽의 파티션을 분산시켜 저장합니다.
이를 통해 클러스터 내 브로커들이 장애가 발생하더라도 데이터의 유실을 방지할 수 있습니다.

토픽별로 리플리케이션 수를 지정할 수 있으며, 기본값은 1입니다.

<img width="1216" alt="image" src="https://user-images.githubusercontent.com/53790137/226359211-f4880633-fb37-4ca5-b2ea-369ffa30c74f.png">

## Replication 개수
리플리케이션 수가 커지면 안전성은 높아지지만 그 만큼 브로커 리소스를 많이 사용하게됩니다.
따라서 복제에 대한 오버헤드를 줄여서 최대한 브로커를 효율적으로 사용하는 것을 권장합니다.

브로커의 개수와 리플리케이션의 개수는 다음과 같은 관계를 같습니다.
```
(브로커 개수) >= (리플리케이션 수)
```

## 리더와 팔로워
> 메시지의 저장과 소비는 리더 브로커에서만 이루어집니다. 팔로워는 리더의 메시지를 복제하는 역할만 합니다.

`리더`는 리플리케이션으로 분산저장되는 브로커들 중 하나가 선정되며, 모든 메시지의 소비와 저장은 리더에서만 이루어집니다.

`팔로워`는 지속적으로 리더가 새로운 메시지를 받았는지 확인하고, 새로운 메시지가 있다면 리더에게 해당 메시지를 요청합니다. 
그래서 리더에 문제가 발생하여 메시지를 저장, 소비할 수 없는 상황이 발생하더라도 팔로워가 리더를 대신할 수 있습니다.

## ISR (In-Sync Replica)
> 리더와 팔로워가 묶인 논리적인 그룹을 ISR(In-Sync Replica)라고 합니다. 리플리케이션을 통해 동기화된 리플리카 그룹이라고도 합니다. 

하나의 파티션에는 리더와 팔로워가 존재하며, 이들은 ISR이라는 그룹으로 묶여있습니다.

리더에 장애가 발생하면 ISR 그룹에 속한 팔로워들 중 하나가 리더로 선출됩니다.

ISR 내의 팔로워들은 리더와의 데이터 일치를 유지하기 위해 지속적으로 리더의 데이터를 pull 합니다.

리더는 ISR 내의 팔로워가 특정 주기의 시간만큼 pull 요청을 보내지 않는다면 해당 팔로워가 리플리케이션 동작에 문제가 발생
했다고 판단하여 ISR 그룹에서 제외시킵니다.

한번 추방된 팔로워는 다시 ISR 그룹에 포함되기 위해서는 리더로부터 데이터를 pull 받아야 합니다.

## 커밋과 오프셋
> `커밋`되었다는 것은 리플리케이션 팩터 수의 모든 리플리케이션이 전부 메시지를 저장했음을 의미합니다. 
> `오프셋`은 파티션 내의 메시지의 위치를 의미합니다.
> `컨슈머`는 커밋된 메시지만 소비할 수 있습니다.

ISR 내에서 모든 팔로워의 복제가 완료되면, 리더 브로커는 마지막 커밋 오프셋 위치를 로컬 디스크의 `replication-offset-checkpoint` 파일에 저장합니다.
(이렇게 저장된 마지막 커밋 오프셋을 `하이워터마크`라고 부릅니다.)

컨슈머는 커밋된 메시지만 소비할 수 있도록 하여 데이터의 `일관성을 보장`합니다.

## 리플리케이션 동작
> 카프카는 리더와 팔로워 간의 리플리케이션 동작을 처리할 때 서로의 통신을 최소화할 수 있도록 설계함으로써 리더의 부하를 줄였습니다.

카프카로 향하는 수많은 메시지의 읽고 쓰기를 처리하는 리더는 매우 바쁘게 동작을 합니다.
그런데 리플리케이션을 위해 팔로워들과 많은 통신을 주고받거나 많은 관여를 한다면 카프카의 장점인 고성능을 내기 어렵습니다.

그래서 카프카는 보통의 MQ와는 다르게 **리더와 팔로워 사이에서 ACK를 주고 받는 통신이 없습니다.**

커밋을 위해 카프카는 다음의 과정을 거칩니다.
1. 메시지가 리더에 도착하여 n번 오프셋에 저장됩니다.
2. 팔로워들로부터 n번 오프셋 메시지에 대한 pull 요청이 들어옵니다.
3. 요청을 받은 리더는 해당 팔로워가 n-1번 오프셋에 대한 리플리케이션 동작이 성공했음을 인지합니다.
4. 오프셋 n-1에 대해 커밋 표시를 한 후 하이워터마크를 증가시킵니다.
5. 리더는 pull요청에 대한 응답에 n-1번 오프셋 메시지가 커밋되었다는 내용도 함께 전달합니다.

이렇게 카프카는 ACK 통신을 사용하지 않고 팔로워들이 pull하는 방식으로 동작함으로써 리더의 부하를 줄여 성능을 높였습니다.

## 참조
- 실전 카프카 개발부터 운영까지