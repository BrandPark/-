# Monolith Architecture

`Monolith Architecture`란 **프로젝트의 구성요소들이 강하게 결합되어 있어 하나의 큰 덩어리를 이루는 전통적인 설계 방식**입니다.

대부분의 프로젝트 첫 시작은 하나의 프로젝트 안에 모든 도메인 모듈이 들어있는 Monolith 구조입니다. 

![image](https://user-images.githubusercontent.com/53790137/151798027-8446cf0f-0e43-4e56-abfe-a724c17c82d8.png)

각 도메인 모듈들은 강한 결합도를 가지고 있어서 하나의 프로젝트에 존재합니다. 버전관리 또한 하나의 레포지토리에서 관리될 것입니다. 

또한 RDB를 사용한다면 보통 DB 저장소도 하나만을 사용하게 됩니다. 왜냐하면 하나의 트랜잭션에 여러 테이블이 조인되기 때문이죠.

# 규모가 커진 Monolith Architecture

서비스의 규모가 커지면 팀을 나눠서 개발해야합니다. 

<img src="https://user-images.githubusercontent.com/53790137/151799413-2a5a5cf2-586b-4dd3-8b2c-796ecdfa6299.png" width="400" height="300">

`주문팀`과 `상품팀`이 나뉘었습니다. 하지만 **단일 Repository를 사용하기 때문에 다음과 같은 문제가 발생**합니다.

#### 1. Branch Merge시 Conflict

여러 팀이 동시에 하나의 Repository에서 작업하기 때문에 **Merge Conflict가 자주 발생**합니다.

#### 2. QA의 범위를 잡기가 힘들다.

각 팀이 각자 브랜치를 따서 작업을 하고 정책도 다르기 때문에 **QA를 어디까지 해야하는지 불분명**합니다.

그래서 **QA팀에 요구하거나 정기 배포일**을 정할 필요가 있습니다.

#### 3. 배포 이슈

팀의 개발 속도가 다르고 일정도 다르기 때문에 배포 이슈가 발생합니다. 

Push만 전문적으로 하는 인프라 운영팀이 생기기도 합니다. 

## Repository 분리

위의 문제들은 개발 주기가 다른 두 팀이 하나의 레포지토리를 사용하여 발생하는 것으로 보입니다. 그렇다면 분리해보겠습니다.

<img src="https://user-images.githubusercontent.com/53790137/151802651-e8bb72ee-7481-49a2-921f-a97b575549a4.png" width="400" height="300">

구조상으로 문제가 해결되었을 것 같습니다. 하지만 새로운 문제들이 생깁니다.

#### 1. Repository를 나누었지만 의존성이 남아있다.

`주문팀`과 `상품팀`이 사용하는 도메인 `Order`과 `Product`는 **의존성을 갖고 있을 확률이 높습니다.** 주문을 하려면 상품정보를 가져와야 하기 때문이죠.

그렇게 되면 이 문제를 해결하기 위해 `Share`라는 저장소를 만들어서 **의존성이 있는 코드 또는 공통 코드들을 모아놓고 사용하게됩니다.**

이렇게 하면 실질적인 개발은 보통 Share에서 이루어지게 됩니다. 약간이라도 재사용 될 것 같으면 Share에 개발을 하기 때문이죠.

#### 2. 정기 배포일이 여전히 필요.

Share라는 공통 코드가 생기면서 **`주문팀`과 `상품팀`의 코드의 싱크를 맞춰야 합니다.**

즉, 여전히 **정기 배포일이 필요**하고 오히려 두 팀이 같이 모니터링 해야하기 때문에 좀 더 큰 작업이 됩니다.

# 콘웨이의 법칙

<img src="https://user-images.githubusercontent.com/53790137/151805159-43012afb-ea5a-4926-98a9-f8c70f5ed4d7.png" width="400" height="300">

`콘웨이의 법칙`은 **시스템의 구조는 설계하는 조직의 커뮤니케이션 구조를 따라간다**는 법칙입니다. 

쉽게 말해 역할을 분담하게 되면서 역할에 따라 시스템 구조가 나뉜다는 의미입니다.

이렇게 너무 많은 통신 관계를 갖는 것은 프로젝트의 개발속도를 늦출 뿐만 아니라 책임도 불분명해져 진정한 위험이 됩니다.

# 모놀리스 장단점
#### 장점
- **개발이 단순**합니다. Repository 하나 체크아웃하여 사용하면 됩니다.
- **배포가 단순**합니다. 하나만 배포하면 됩니다.
- **Scale-out이 단순**합니다. 서버 하나만 복사하면 되기 때문입니다. (물론 DB를 하나 사용하기 때문에 한계가 있습니다.)

#### 단점
- **개발부터 배포 주기가 느립니다.** 일정이 다른 팀들이 서로 커뮤니케이션을 하면서 진행해야하기 때문이죠.
- 코드가 **높은 결합도**(의존성)를 갖고있습니다.
- 기술 스펙을 바꾸기가 어렵습니다.
- **코드에 대한 책임과 소유권이 불분명**해집니다. 다른 팀에게 책임을 위임하는 식으로 진행되기 때문이죠.

# 참고
- [토크ON세미나: Spring Cloud를 활용한 MSA 기초 1강](https://www.youtube.com/watch?v=D6drzNZWs-Y&ab_channel=SKplanetTacademy)
