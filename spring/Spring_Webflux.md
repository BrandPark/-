# Spring Webflux

스프링 5.0에 추가된 리액티브 스택 웹 프레임워크입니다. 완전하게 `논블록킹`으로 동작하며 Reactive Streams back pressure를 지원하고, Netty,
Undertow, Servlet 3.1+ 컨테이너를 지원합니다.

## 왜 만들어졌나?

- 논블록킹 I/O를 사용하여 적은 쓰레드로 동시 처리를 제어하고 적은 하드웨어 리소스로 확장하기 위해 만들어졌습니다.
    - Servlet 웹 스택은은 블록킹 I/O를 사용하기 때문에 새로운 논블로킹 웹 스택이 필요했습니다.
    - 서블릿 3.1 부터도 논블록킹 I/O를 위한 API를 지원하지만, Filter, Servlet등 동기 처리를 위한 다른 API들은 여전히 블록킹 I/O를 사용합니다.
- 함수형 프로그래밍을 사용하여 더 간결하고 명확한 코드를 작성하기 위해 만들어졌습니다.
    - 자바 8에서 등장한 람다 표현식 덕분에 자바에서도 함수형 프로그래밍을 할 수 있게 되었습니다.
    - 웹 플럭스를 사용하여 비동기 로직을 선언적으로 작성할 수 있습니다.

## Reactive Streams

> **💡Reactive?**
>
> `Reactive`는 반응형이라는 뜻을 가지고 있으며, I/O 이벤트에 반응하여 데이터를 처리한다는 의미입니다.

`Reactive Streams`는 back pressure를 통해 비동기 컴포넌트간의 상호작용을 정의한 간단한 스펙입니다.
논블록킹은 작업을 기다리기 보다는 완료되거나 데이터를 사용할 수 있게 되면 반응하므로 리액티브라 부를 수 있습니다.

### Back Pressure

논블록킹 I/O를 사용하면 발생할 수 있는 문제점 중 하나는 프로듀서의 속도를 컨슈머의 속도가 따라잡지 못할 때 발생하는 문제입니다.
`Back Pressure`는 프로듀서의 속도가 컨슈머의 속도를 압도하지 못하도록 제어하는 것을 의미합니다.

> **🚧 프로듀서의 속도를 늦출 수 없다면 어떻게 할까?**
>
> 리액티브 스트림의 목적은 데이터 처리의 매커니즘과 경계를 확립하는 것입니다. 프로듀서가 속도를 늦출 수 없다면 버퍼에 담을, 데이터를 날릴지, 실패로 처리지 결정해야합니다.

## Reactor 
`Reactor`는 스프링 웹플럭스가 선택한 리액티브 라이브러리이며 `Mono`와 `Flux`라는 두 가지 타입을 제공합니다.
모든 연산자는 논블록킹 back pressure를 지원하며 서버사이드 자바에 초점을 맞춰서 스프링과 긴밀히 협력해서 개발되었습니다.

> **💡 리액티브 라이브러리?**
> 
> 저수준의 Reactive streams 스펙을 구현한 고수준의 함수형 API 라이브러리입니다.

웹플럭스는 리액터를 핵심 라이브러리로 사용하지만, 다른 리액티브 라이브러리도 사용가능합니다.
웹플럭스 API는 순수한 `publisher`를 입력받아 내부적으로 리액터 타입으로 맞추고, 이를 사용해서 `Mono`나 `Flux`를 반환합니다.
이 규칙만 만족하면 되기 때문에 다른 리액티브 라이브러리를 사용하더라도 출력형식만 맞춰주면 가능합니다.

## Netty
`Netty`는 비동기 이벤트 기반 네트워크 애플리케이션 프레임워크입니다.
스프링 웹플럭스에서는 기본적으로 `Netty`를 사용하며, 그 이유는 보통 비동기 논블록킹에 많이 사용되며 클라이언트와 서버가 리소스를 공유할 수 있기 때문입니다.
클라이언트와 서버에서 모두 리액터 netty를 사용한다면 기본적으로 이벤트 루프 리소스를 공유 합니다.

## Performance
웹플럭스를 사용한다고 무조건 성능이 좋아지는 것은 아닙니다. 리액티브와 논블록킹을 사용하면서 얻을 수 있는 주요이점을 이해하고 사용해야 성능적인 이점을 얻을 수 있습니다.

리액티브와 논블록킹의 주된 이점은 다음과 같습니다.
1. 고정된 적은 쓰레드와 적은 메모리로도 확장할 수 있습니다.
    - 쓰레드가 블록되지 않고 계속 사용되기 때문에 적은 쓰레드로 요청을 처리할 수 있습니다.
2. 예측가능한 방법으로 확장하기 때문에 부하 속에서도 일관된 성능을 보장합니다.
    - 느리고 예측이 불가능한 네트워크 I/O 시간에 영향을 받지 않기 때문에, 요청의 처리 시간이 예측가능하며 이를 모니터링하여 확장가능합니다.

한가지 예를 들어보겠습니다. 하나의 요청에서 외부 API를 여러개 호출해야하는 상황이고 쓰레드 풀이 꽉차서 처리량이 떨어지는 상황입니다.
`블록킹 I/O` 방식은 공통의 리소스인 쓰레드 풀의 쓰레드를 사용하여 요청을 처리합니다.
그런데 네트워크 I/O가 발생할 경우 각 I/O가 완료될 때까지 쓰레드는 블락되며 이 I/O들은 응답시간이 모두 달라서 예측이 불가능합니다.
즉, 공통자원인 하나의 쓰레드가 얼만큼 처리할 수 있는지 예측하기가 쉽지 않습니다. 그렇다고 무작정 쓰레드 풀을 늘리면 메모리가 많이 사용됩니다.

그러나 `논블록킹 I/O` 방식은 쓰레드가 블락되지 않고 I/O 이벤트가 발생할 때까지 다른곳에서 사용됩니다.
따라서 예측불가능한 네트워크 I/O에 영향을 받지 않기 때문에 하나의 쓰레드가 처리할 수 있는 요청의 양이 예측가능합니다.
