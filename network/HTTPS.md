# HTTPS

`HTTPS`는 HTTP의 확장으로 통신프로토콜로 `TLS`(Transport Layer Security)또는 이전 이름인 `SSL`(Secure Socket Layer)를 사용하여 **암호화**합니다. 

`HTTP`는 데이터가 평문으로 전송되기 때문에 누군가 네트워크에서 패킷을 가로채면 보안 이슈가 발생합니다.

`HTTPS`는 TLS/SSL 암호화를 거쳐 크게 두 가지 기능을 합니다.
1. 접속한 사이트의 서버가 `CA(Certification Authority)`로 부터 인증받은 기업인지, 즉 **신뢰할 수 있는 사이트인지** 알려줍니다.
  - 세계적으로 인정된 CA는 인증기관으로써 검증을 마친 기업 서버에게 CA 인증서를 발급합니다. 이 인증서에는 **서버의 공개키가 CA 서버의 비밀키로 암호화** 되어 들어 있습니다.
2. HTTP 메시지를 암호화하여 중간에서 가로채도 해독하지 못하게 합니다.

정리하면 HTTPS는 **내가 접속하는 사이트가 신뢰 할만한 사이트인지 알려주고, 보내는 데이터를 암호화하여 중간에서 가로채도 해독하지 못하게 하는 것**입니다. 

## TLS/SSL Handshake

SSL은 Handshake는 서버와 클라이언트의 통신 전에 **서버의 SSL 인증서(CA 인증서)의 신뢰성을 확인하고 서버의 대칭키를 안전하게 클라이언트에게 전달하는 과정**입니다. 

Handshake를 마치면 클라이언트와 서버는 **대칭키를 통해 빠르고 안전하게 통신이 가능**해집니다.

![image](https://user-images.githubusercontent.com/53790137/152183277-ffbfe494-2556-43b7-8aaa-270d25e98fea.png)

1. `클라이언트`는 서버에게 **암호화 정보와 함께 랜덤 바이트 문자열(Client Random)을 전송**합니다. 랜덤 바이트 문자열은 나중에 대칭키를 만들때 사용됩니다. 
2. `서버`도 클라이언트에게 **랜덤 바이트 문자열(Server Random) 생성하여 메시지에 넣어 응답합니다. 이때 TLS인증서도 함께 전송**합니다. 서버에서도 클라이언트의 인증을 필요로 한다면 클라이언트 인증서 요청을 보냅니다.
3. `클라이언트`는 브라우저에 저장되어 있는 CA 공개키로 복호화 후 CA목록을 확인하여 **인증서의 신뢰성을 확인**합니다. 이때 클라이언트는 **서버의 공개 키도 얻게 됩니다. **
4. `클라이언트`는 **"Premaster secret"이라는 랜덤 바이트 문자열을 생성해 서버의 공개키로 암호화 하여 보냅니다.** 이때 서버가 클라이언트 인증을 요청했었다면 디지털 인증서를 같이 보냅니다. 
5. `서버`는 "Premaster secret"을 복호화하고, **`클라이언트`와 `서버`는 지금까지 나누었던 랜덤 바이트(client random, server random, premaster secret)로 대칭키를 생성**합니다.
6. `클라이언트`가 서버에 완료 메시지를 전송합니다. **이 메시지는 대칭 키로 암호화**되어있고 클라이언트가 **준비가 완료되었음**을 알립니다.
7. `서버`는 완료 메시지를 대칭키로 복호화하고 **자신도 준비가 완료되었다는 finished 메시지를 보냅니다.**
8. `클라이언트`와 `서버`는 이제 대칭키를 통해 데이터를 암호화하여 주고 받습니다. 

### 왜 처음부터 대칭키를 전달하지 않을까요? (1~3)

대칭키 방식은 암호화/복호화가 하나의 키로 모두 가능합니다. 대칭키를 전달하는 과정에서 이 키를 탈취당한다면 보안 이슈가 발생합니다.

### 왜 공개키 방식으로 계속 통신하지 않고 대칭키를 만들까요? (5)

공개키 방식은 비밀키만 탈취당하지 않는다면 안전합니다. 하지만 암호화/복호화 과정이 복잡하여 대칭키 방식보다 속도가 느립니다. 

통신을 주고받을 때마다 공개키를 사용하는 것은 비효율적이라고 할 수 있습니다.

### Client Random과 Server Random만 있으면 될텐데 왜 Premaster secret이 필요한가요? (4)

Client Random과 Server Random은 암호화 되지 않은 문자열이기 때문에 탈취를 당했을 가능성이 있습니다.

그래서 공개키 방식으로 암호화한 Premaster secret을 한번 더 보내서 이것들로 서버와 클라이언트가 대칭키를 생성합니다.

이 과정은 클라이언트가 공개키를 가졌다는 사실을 서버에게 알리는 과정이기도 합니다. 

### 대칭키를 생성하면 바로 통신하면 될텐데 왜 준비 완료 메시지를 보내나요? (6~7)

handshake는 항상 서로가 준비가 되었음을 확인하는 과정이 필요합니다. 각자가 대칭키를 생성하는 단계를 지났다고 해도 대칭키를 생성하는데 실패했을 수도 있습니다. 

그래서 대칭키로 암호화한 메시지를 주고 받음으로써 서로가 대칭키를 가지고 있다는 것을 확인하는 것이죠.




