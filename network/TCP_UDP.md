# TCP와 UDP

`TCP`와 `UDP`는 4계층 표준 프로토콜로서 IP패킷에 PORT가 들어있는 4계층 헤더를 추가하여 프로세스를 찾아갈 수 있도록 해주는 기능을 합니다.

## UDP

`UDP`는 User Datagram Protocol의 약자로 IP패킷에 PORT 번호와 헤더나 데이터의 손상을 감지할 수 있는 Checksum 정도만 추가되어 있습니다.

따라서 흐름제어나 오류제어가 필요하다면 애플리케이션에서 직접 구현해야 합니다.

**비연결형**이기 때문에 속도가 빠르며, 특별한 기능이 없어서 4계층 프로토콜을 커스터마이징 할 때 사용됩니다.

UDP는 가볍기 때문에 오버헤드가 적어 브로드캐스트나 멀티캐스트에 효과적으로 사용될 수 있습니다. 

## TCP

`TCP`는 **연결지향형 전송제어 프로토콜**입니다. 이름 그대로 연결을 지향하며 전송을 제어하는 기능을 가지고 있습니다.

`3 way-handshake` 연결 과정과 `4-way handshake` 연결 해제 과정을 거치기 때문에 UDP에 비해 속도가 느립니다. 

하지만 **데이터의 순서와 전달을 보증**하여 신뢰성이 높은 프로토콜입니다. 

## 3 way-handshake (연결)

TCP가 연결지향형 프로토콜인 이유는 **논리적인 연결 과정**을 거치기 때문입니다. 

데이터를 보내기전에 3번 연결을 주고 받음으로써 논리적인 연결을 보장하는 것이 `3 way-handshake`입니다.

논리는 다음과 같습니다. 

1. 클라이언트 : 너에게 데이터를 보내고 싶은데 연결이 되면 말해줘
2. 서버 : 응. 잘 연결됐어 너도 연결되면 말해줘.
3. 클라이언트 : 잘 연결됐구나! 나도 연결됐어! 이제 보내도 되겠다. 

![image](https://user-images.githubusercontent.com/53790137/151968918-5179698b-1ac2-462d-ad41-77d7c9b05f06.png)

1. `클라이언트`는 서버에게 연결이 가능한지 `SYN(m)` 패킷을 보냅니다. 
2. `서버`는 SYN(m)의 응답 패킷 ACK(m+1)과 함께 연결이 가능한지 `클라이언트`에게 SYN(n) 패킷을 같이 보냅니다.
3. `클라이언트`는 서버의 SYN(n) 패킷을 받았다는 응답 메시지 ACK(n+1)을 보내면서 논리적 연결이 형성됩니다.

## 4 way-handshake (연결해제)

연결을 해제할 때는 4번의 응답과정을 거쳐야합니다.

논리는 다음과 같습니다.
1. 클라이언트: 나 이제 연결 끊고 싶어. 끊을 수 있니?
2. 서버: 연결을 끊고 싶구나! 잠시만 기다려 줄래? 남아있는 것만 보내고!
3. 서버: 다 보냈다. 이제 끊자! 
4. 클라이언트: 그래 끊자! 너부터 끊어! 난 너가 잘 끊은 것 같으면 그때 끊을게!

이때 먼저 연결을 끊고자 하는 쪽을 `Active Close`, 상대 쪽을 `Passive Close`라 합니다.

![image](https://user-images.githubusercontent.com/53790137/152086365-1141f69d-d41c-4ff0-aef1-e44cec163b83.png)

설명의 편의를 위해 Active Close쪽을 클라이언트, Passive Close 쪽을 서버라고 하겠습니다. 

1. `클라이언트`는 서버에게 FIN flag를 1로 설정한 패킷(FIN)을 보내 연결을 해제하고 싶다고 알립니다.
2. `서버`는 FIN을 받으면 정상적으로 받았다고 클라이언트에게 ACK 패킷을 보냅니다. 
  - 이때 출력 버퍼에 남아있는 데이터를 모두 보내고 닫아야 하기 때문에 바로 close하지 않고 `CLOSE_WAIT`상태가 되어 남아있는 데이터가 모두 전송되는 것을 기다립니다. 
3. `서버`는 남아있는 데이터를 모두 보내고 난 후 클라이언트에게 FIN flag를 1로 설정한 패킷(FIN)을 보내 연결을 해제하자고 알립니다.
  - 이때 `LAST_ACK` 상태가 되어 클라이언트의 응답(ACK)을 기다립니다. 일정 시간동안 ACK를 받지 못하면 FIN 패킷을 다시 보냅니다. 
5. `클라이언트`가 서버로부터 FIN을 성공적으로 받으면 ACK를 보내서 서버에게 잘 받았다고 알립니다.
  - 이때 `TIME_WAIT`상태가 되어 서버가 잘 닫혔는지 확인하는 시간을 가집니다. 
7. `서버`는 ACK를 받으면 소켓을 Close 합니다. 
8. `클라이언트`는 일정시간 동안 서버로 부터 FIN 패킷이 다시 오진 않는지 기다리고 오지 않으면 Close합니다.

## CLOSE_WAIT & TIME_WAIT
#### CLOSE_WAIT

`Passive Close`쪽이 **소켓을 닫기 위해 출력 버퍼가 비워지는 것을 기다리는 상태**입니다.

출력 버퍼가 비워지면 FIN 패킷을 전송합니다.

#### TIME_WAIT

`Active Close`쪽이 **상대 소켓이 잘 닫혔는지 일정시간 동안 확인하는 상태**입니다.

잘 닫혔다면 아무 응답이 없을 것이고, 잘 닫히지 않았다면 FIN 패킷을 다시 한번 보낼 것입니다.
