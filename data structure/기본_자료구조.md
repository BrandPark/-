# Array
List형 자료구조 중에 읽는 속도가 가장 빠르다. 만약 인덱스를 알고 있다면 O(1)이 소요된다.

### 특징
- 비슷한 타입의 데이터를 모을 때 쓰는 자료구조
- 불변 크기 리스트
- 연속된 메모리 주소로 지정된 크기만큼 동적 할당된다.

### 장점
- index만 알고있다면 O(1)로 바로 접근 가능하기 때문에 Random Access 가능.
- Binary Search 가능
- 즉 읽는 속도가 빠르다.

### 단점
- 크기가 변하지 않는다.
- 중간 요소를 삭제하면 빈공간이 생긴다. 메꾸기 위해서는 뒤의 요소들을 당기는 추가적인 작업 필요.
- 삽입의 소요 시간이 배열의 마지막을 제외하곤 O(N)이 소요된다. 

<br>

# LinkedList
List형 자료구조 중에 Head에 한정하여 삽입, 삭제가 가장 빠르다. 

### 특징
- 포인터를 통해 여러 노드가 Chain 형태로 연결되어있다.
- 종류는 양방향 또는 단방향이다.
  - 단방향이라면 Head가 1개, 양방향이라면 2개이다.
- 포인터로 연결만 하면 되므로 가변 크기 리스트이다.

### 장점
- Head에 데이터를 삽입하거나 삭제할 때 O(1)로 매우 빠르다.
- 가변 크기 리스트

### 단점
- 탐색을 할 땐 Head에서부터 순차적으로 탐색해야 하기 때문에 Random Access가 불가능하다. (O(N))
- 중간에 요소를 삽입할 때 탐색을 우선해야하기 때문에 O(N)이 소요된다.
- 포인터를 위한 추가적인 메모리가 필요하다.

<br>

# ArrayList
내부에 배열을 가지고 있다.

### 특징
- 내부에 배열을 갖고 있다.
- 배열이 포화된 상태에서 삽입을 시도하면 새로운 배열을 만들어 복사한다. (O(N))

### 장점
- 가변 크기 리스트
- 나머지 장점은 배열과 같다.

### 단점
- 삽입, 삭제 할 때 후위 요소를 이동시키는 작업이 필요해서 느리다.
- 공간이 부족할 때 새로운 배열을 만들어 비용이 발생한다.

<br>

# Stack
가장 나중에 들어간 것이 먼저 나오는 구조체. LIFO(Last In First Out)

### 언제 사용되나?
- 콜 스택
- 역순 출력
- 괄호 쌍 체크
- 연산에서도 내부적으로 스택이 사용 됨.
- DFS

### 스택 구현 클래스
- 배열로 구현 : Stack<E>
- 연결 리스트로 구현 : LinkedList<E>, ArrayDeque<E>

Stack<E>의 경우 Vector를 상속하기 때문에 동기화 작업이 되어 있다. 

<br>

# Queue
가장 먼저 들어간 것이 먼저 나오는 구조체. FIFO(First In First Out)

### 언제 사용되나?
- 버퍼, 대기 큐
- BFS
  
### 큐 구현 클래스
- 연결리스트로 구현 : LinkedList<E>, ArrayDeque<E>
  
<br>

# Heap
가장 큰 값 또는 가장 작은 값을 꺼낼 수 있도록 반정렬된 완전 이진트리. 
  
중복 값을 허용하며 주로 배열로 구현된다.

최대힙 : 부모 노드의 키 값 >= 모든 자식 노드들의 키 값
  
### 언제 사용되나?
우선 순위 큐를 구현할 때 효과적으로 사용된다.
- 작업 스케줄링

<br>
  
# Tree
노드와 간선으로 이루어져 있고 사이클이 없는 그래프의 특수한 형태

루트 노드가 존재한다.

### 언제 사용되나?

## Binary Search Tree

### 특징
- 탐색에 특화된 정렬된 트리 구조.
- 각 노드의 자식이 2개 이하이다.
- 각 노드의 왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 크다.
- 중복 노드가 없어야 효율적이다. 
  - 검색이 목적이기 때문에 중복된 경우 count나 연결 리스트를 이용하여 해결할 수 있다.
- 순회는 중위순회 방식으로 진행된다. 
  
<br>
  
# HashTable
효율적인 탐색을 위한 자료구조로서 키(key)를 값(value)에 대응 시킨다.
  
### 특징
- 키의 자료형은 보통 int 혹은 long이다. 키의 자료형은 무한한데 반해 int의 개수는 유한하기 때문에 서로 다른 두 개의 키가 같은 해시 코드를 가리킬 수 있다.
- 해싱을 통해 키 값을 구한다.
- 해싱 값이 충돌이 잘 나지 않도록 하는 것이 좋은 성능의 지표다.

### HashTable에 데이터 넣는 과정.
1. 해싱 함수를 이용해 해싱 값을 계산한 후 배열의 인덱스를 구한다. (ex. hash(key) & arr_length)
2. 배열의 각 인덱스에는 키와 값으로 이루어진 연결 리스트가 존재한다. 해당 연결리스트에 추가한다.
  
### 충돌 문제 피하기
1. 체이닝
  : 위와 같이 연결 리스트로 충돌을 피하는 방식이다. 메모리 문제가 발생할 수 있다.
2. Open Addressing 
  : 충돌이 일어날 경우 다음 주소에 저장하는 방식
3. 선형 탐사
  : 정해진 고정 폭으로 주소를 옮기며 비어있으면 넣는 방식

  
  
